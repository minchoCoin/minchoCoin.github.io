---
title: "1.운영체제 - 서론"
last_modified_at: 2023-09-17T11:53:12+09:00
categories:
    - os
tags:
    - os

author_profile: true

toc: true
toc_label: "My Table of Contents"
---
# 운영체제란

**운영체제**는 컴퓨터 하드웨어를 관리하는 소프트웨어이다. 컴퓨터 사용자와 하드웨어 사이에서 중재자 역할을 한다.<br>

# 1.1 운영체제가 할 일

## 컴퓨터 시스템의 4가지 구성요소
 - 하드웨어: CPU, I/O장치로 구성되며 기본 계산용 자원 제공
 - 응용 프로그램: 워드 프로세서 등은 사용자의 계산 문제를 해결하기 위해 자원이 어떻게 사용될지를 정의함
 - 사용자
 - 운영체제: 다양한 응용 프로그램 간의 하드웨어 사용을 제어하고 조정 즉 다른 프로그램이 유용한 작업을 수행할 수 있는 환경 제공

## 사용자 관점
 - 운영체제는 대부분 사용의 용이성을 위해 설계되었다
 - 사용자는 하드웨어와 소프트웨어 자원이 어떻게 공유되느냐는 신경쓰지 않음
## 시스템 관점
 - 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램
 - 자원 할당자
 - 자원의 관리자
 - 입출력 장치와 사용자 프로그램을 제어하는 제어 프로그램
## 운영체제의 정의
 - 운영체제를 주문할 때 공급 업체가 제공하는 모든 것(?)
 - 컴퓨터에서 항상 실행되는 프로그램 중 하나(커널)
 - 시스템 프로그램: 운영체제와 관련되어 있지만 반드시 커널의 일부는 아님
  - 응용 프로그램: 시스템 작동과 관련되지 않은 모든 프로그램

# 컴퓨터 시스템의 구성
 - 하나 이상의 CPU, 구성요소와 공유 메모리 사이의 엑세스를 제공하는 공통 버스를 통해 연결된 여러 장치 컨트롤러로 구성
 - 장치 컨트롤러에는 장치 드라이버가 있음
 ```
 CPU --------------------------
                               |
 Disk - disk controller ------- 
                               | system bus
 mouse ------                  | --------------Memory     
 keyboard --- USB controller ---
 printer ----                  |
                               |
 monitor ---- graphic adapter --
 ```
 ## 개요
 - 하드웨어는 시스템 버스를 통해 CPU에 신호를 보내 **인터럽트**를 발생시킨다.

 - CPU가 인터럽트 되면, CPU는 하던 일을 중단하고 즉시 인터럽트 서비스 루틴이 실행된다.
 
 - 인터럽트는 적절한 서비스 루틴으로 제어 전달
 - 루틴은 인터럽트 고유의 핸들러 호출
 - 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어있는 인터럽트 벡터를 이용하여 보통 인터럽트가 ISR로 제어 전달

 - 인터럽트는 반드시 현재의 상태를 저장해야하며 복귀전에 상태를 복원해야한다(레지스터 값 등).
## 구현
 - CPU는 하나의 명령어의 실행을 완료할때마다 인터럽트 요청 라인을 검사함
 - 아래 그림과 같이 동작함
 - 중요한 처리 중에 인터럽트를 비활성화할 수 있음
 - 우선순위가 높은/낮은 인터럽트를 구분
 ```
 장치 드라이버 입출력 개시(CPU) 
 ->입출력 개시(I/O controller)
 ->입력 준비 완료, 출력 완료, 에러 발생 시 인터럽트 신호 발생(I/O controller)
 ->CPU가 인터럽트를 전달 받으면 받은 인터럽트의 번호를 인터럽트 벡터의 인덱스로 활용하여 제어를 인터럽트 핸들러로 넘김
 -> 인터럽트 핸들러가 데이터를 처리하고 복귀
 -> CPU는 인터럽트로 중단된 작업 재개
 ```
## 저장 장치 구조
 - CPU는 메모리에서만 명령을 가져올 수 있다
 - 따라서 프로그램을 실행하려면 프로그램을 메모리에 적재해야함
 - 부트스트랩 프로그램: 컴퓨터 전원을 켤 때 가장 먼저 실행되는 프로그램으로, 운영체제를 적재함
 - 부트스트랩 프로그램은 일반적으로 EEPROM이나 펌웨어에 저장됨
 - 프로그램은 HDD나 NVM 같은 보조저장장치에 저장된다
 - 저장장치 계층 구조는 (레지스터-캐시-메인메모리(1차 저장장치)-비휘발성메모리-하드디스크(2차 저장장치)-광학디스크-자기테이프(3차 저장장치))이며 오른쪽으로 갈수록 엑세스시간은 느리지만 저장용량은 더 크다
## 입출력 구조
 - 인터럽트 구동 방식의 I/O는 소량의 데이터를 옮기는데는 효과적이지만, NVS I/O 같은 대용량 데이터 이동에는 적합하지 않음
 - 직접 메모리 엑세스(DMA) : 장치 제어기가 CPU의 개입 없이 메모리->장치 버퍼 또는 그 반대로 데이터 전송. 블록 단위 전송이 완료될때마다 인터럽트 발생

# 컴퓨터 시스템 구조

## 단일 처리기 시스템
 - 코어는 명령 실행 + 레지스터로 구성
 - 단일 처리 코어를 가진 범용 CPU가 하나만 있는 경우이다.

## 다중 처리기 시스템
 - 단일 코어 CPU 가있는 두개 이상의 프로세서
 - 처리량 증가
 - N개의 프로세서가 있다고 성능이 N배 증가하지 않음(공유 자원이나 프로세서 관리 등으로 인한 오버헤드)
 - 최근에는 다중 코어 시스템(한 프로세서에 코어가 여러개)도 포함 - 칩 간 통신보다 칩 내 통신이 효율적
 - NUMA(non-uniform memory access): 각 CPU에 자체 로컬 메모리 제공

# 운영체제의 작동
 - 운영체제를 적재하는 부트스트랩 프로그램은 펌웨어로 저장됨. 
 - 운영체제가 적재되면 시스템 데몬이 실행되고, 리눅스에서 시스템데몬(systemd)은 다른 많은 데몬을 실행한다

 - 시스템은 어떤 이벤트가 발생할 때 까지 기다린다.(interrupt driven)
## multiprogramming and multitasking
  - 멀티 프로그래밍은 CPU가 항상 한 개는 무언가 실행할 수 있도록 프로그램을 구성하여 CPU 이용률을 높이는 것
    - 어떤 프로세스가 대기해야하는 경우 운영체제는 다른 프로세스로 전환하여 실행한다
  - 멀티 태스킹은 CPU가 여러 프로세스를 전화하며 프로세스를 실행하고, 전환이 자주 발생하여 빠른 응답 시간을 제공한다
    - 여러 프로세스를 저장하는 메모리 관리 시스템과 어떤 프로세스를 실행시키고 중단할지 결정하는 CPU 스케쥴링이 필요
    - 가상 메모리 이용
 
## 이중모드 와 다중모드
 - 운영체제 코드 실행과 사용자 코드 실행 구분 필요
 - 사용자모드와 커널모드가 있음
 - 컴퓨터 하드웨어에 모드 비트를 추가하여 현재 사용자 모드(1)인지 커널모드(0)인지 구별함

 - 시스템 콜은 사용자 프로그램이 운영체제가 수행하도록 지정되어있는 작업(파일 삭제 등)을 운영체제에 요청하는 방법이다. 만약 프로그램이 시스템 콜을 호출하면 커널이 모드 비트는 0으로 바꾸고, 시스템 콜을 실행한다음 다시 모드 비트를 1로 바꾸고 사용자 프로세스로 복귀한다.

 - 커널모드에서만 사용할 수 있는 명령어를 privilleged instruction이라 한다. 예를 들면 커널모드로 전환, I/O instruction, interrupt disable, context switching, clear memory, remove process from memory, set the timer 등이 있다. 

## 타이머
 - 사용자 프로그램이 무한 루프 등으로 제어가 운영체제로 복귀하지 못하는 것을 방지 하기위해 타이머 사용
 - 일정 시간 지나면 인터럽트하여 운영체제가 그 프로세스를 중단할지, 더 많은 시간을 줄지 결정할 수 있다.

# 자원 관리
 - 프로세스 관리
 - 메모리 관리
 - 파일 시스템 관리
 - 대용량 저장장치 관리
 - 캐시 관리
 - 입출력 시스템 관리

# 보안과 보호
 - 보안 : 내부,외부 공격으로부터 시스템 방어
 - 보호 : 컴퓨터 시스템 자원에 대해 프로그램, 프로세스, 사용자의 접근을 제어하는 것

# Reference
 - Abraham Silberschatz 외 2명 지음, 박민규 역, 운영체제, 퍼스트북, 2020
